"""
Main Trading Bot for BRM Markets
Combines Day-Ahead and Intraday trading capabilities with intelligent order management
"""
import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional, Callable
from dataclasses import dataclass, field
from enum import Enum
import json

from auth import initialize_auth, get_authenticator
from config import config
from day_ahead_client import DayAheadClient, BlockOrderRequest, CurveOrderRequest, OrderSide
from intraday_client import (
    IntradayWebSocketClient, 
    IntradayOrder, 
    OrderType, 
    TimeInForce, 
    ExecutionRestriction,
    OrderModificationType
)


class TradingStrategy(Enum):
    """Available trading strategies"""
    SIMPLE_ARBITRAGE = "simple_arbitrage"
    MEAN_REVERSION = "mean_reversion"
    MOMENTUM = "momentum"
    MANUAL = "manual"


@dataclass
class TradingPosition:
    """Represents a trading position"""
    contract_id: str
    area_id: int
    quantity: int  # Positive for long, negative for short
    average_price: float
    timestamp: datetime
    market: str  # "day_ahead" or "intraday"


@dataclass
class TradingSignal:
    """Trading signal generated by strategy"""
    action: str  # "BUY", "SELL", "HOLD"
    contract_id: str
    area_id: int
    quantity: int
    price: float
    confidence: float
    strategy: TradingStrategy
    timestamp: datetime = field(default_factory=datetime.now)


class BRMTradingBot:
    """Main trading bot class for BRM markets"""
    
    def __init__(
        self, 
        client_id: str, 
        client_secret: str, 
        username: str,
        portfolio_id: str,
        strategy: TradingStrategy = TradingStrategy.MANUAL
    ):
        # Initialize authentication
        initialize_auth(client_id, client_secret)
        
        # Bot configuration
        self.username = username
        self.portfolio_id = portfolio_id
        self.strategy = strategy
        
        # Market clients
        self.day_ahead_client = DayAheadClient()
        self.intraday_client = IntradayWebSocketClient(username)
        
        # Trading state
        self.positions: Dict[str, TradingPosition] = {}
        self.active_orders: Dict[str, Dict[str, Any]] = {}
        self.market_data: Dict[str, Any] = {}
        self.configuration: Optional[Dict[str, Any]] = None
        
        # Event handlers
        self.signal_handlers: List[Callable[[TradingSignal], None]] = []
        self.position_handlers: List[Callable[[TradingPosition], None]] = []
        self.order_handlers: List[Callable[[Dict[str, Any]], None]] = []
        
        # Control flags
        self.running = False
        self.auto_trading_enabled = False
        
        # Logging
        self.logger = logging.getLogger(__name__)
        
        # Strategy parameters
        self.strategy_params = {
            "max_position_size": 1000,  # kW
            "max_price": 10000,  # cents
            "min_price": -10000,  # cents
            "risk_limit": 50000,  # EUR
        }
    
    async def start(self):
        """Start the trading bot"""
        self.logger.info("Starting BRM Trading Bot")
        
        try:
            # Connect to Intraday WebSocket
            if await self.intraday_client.connect():
                # Subscribe to essential topics
                await self._setup_subscriptions()
                
                self.running = True
                self.logger.info("Trading bot started successfully")
                
                # Start main trading loop
                await self._main_loop()
            else:
                self.logger.error("Failed to connect to Intraday market")
                
        except Exception as e:
            self.logger.error(f"Error starting trading bot: {e}")
            raise
    
    async def stop(self):
        """Stop the trading bot"""
        self.logger.info("Stopping BRM Trading Bot")
        self.running = False
        self.auto_trading_enabled = False
        
        # Disconnect from WebSocket
        await self.intraday_client.disconnect()
        
        self.logger.info("Trading bot stopped")
    
    async def _setup_subscriptions(self):
        """Setup WebSocket subscriptions for market data"""
        # Subscribe to configuration updates
        await self.intraday_client.subscribe_to_configuration(
            self._handle_configuration
        )
        
        # Subscribe to order execution reports
        await self.intraday_client.subscribe_to_order_execution_reports(
            self._handle_order_execution_report
        )
        
        # Subscribe to private trades
        await self.intraday_client.subscribe_to_private_trades(
            self._handle_private_trade
        )
        
        # Subscribe to local market view (assuming area 1 for Romania)
        await self.intraday_client.subscribe_to_local_view(
            1, self._handle_local_view
        )
    
    async def _main_loop(self):
        """Main trading loop"""
        while self.running:
            try:
                # Update market data
                await self._update_market_data()
                
                # Generate trading signals if auto trading is enabled
                if self.auto_trading_enabled:
                    signals = await self._generate_signals()
                    
                    for signal in signals:
                        await self._execute_signal(signal)
                
                # Check and manage existing positions
                await self._manage_positions()
                
                # Sleep before next iteration
                await asyncio.sleep(1)  # 1 second loop
                
            except Exception as e:
                self.logger.error(f"Error in main loop: {e}")
                await asyncio.sleep(5)  # Wait longer on error
    
    async def _update_market_data(self):
        """Update market data from various sources"""
        try:
            # Get current auctions from Day-Ahead market
            auctions = await self.day_ahead_client.get_auctions()
            self.market_data["day_ahead_auctions"] = auctions
            
            # Get system state
            state = await self.day_ahead_client.get_system_state()
            self.market_data["system_state"] = state
            
        except Exception as e:
            self.logger.error(f"Error updating market data: {e}")
    
    async def _generate_signals(self) -> List[TradingSignal]:
        """Generate trading signals based on current strategy"""
        signals = []
        
        if self.strategy == TradingStrategy.SIMPLE_ARBITRAGE:
            signals.extend(await self._arbitrage_strategy())
        elif self.strategy == TradingStrategy.MEAN_REVERSION:
            signals.extend(await self._mean_reversion_strategy())
        elif self.strategy == TradingStrategy.MOMENTUM:
            signals.extend(await self._momentum_strategy())
        
        return signals
    
    async def _arbitrage_strategy(self) -> List[TradingSignal]:
        """Simple arbitrage strategy between Day-Ahead and Intraday"""
        signals = []
        
        # This is a simplified example - in practice, you'd need more sophisticated logic
        try:
            if "day_ahead_auctions" in self.market_data:
                for auction in self.market_data["day_ahead_auctions"]:
                    # Look for price differences between markets
                    # This is where you'd implement your arbitrage logic
                    pass
        except Exception as e:
            self.logger.error(f"Error in arbitrage strategy: {e}")
        
        return signals
    
    async def _mean_reversion_strategy(self) -> List[TradingSignal]:
        """Mean reversion strategy"""
        signals = []
        # Implement mean reversion logic here
        return signals
    
    async def _momentum_strategy(self) -> List[TradingSignal]:
        """Momentum strategy"""
        signals = []
        # Implement momentum logic here
        return signals
    
    async def _execute_signal(self, signal: TradingSignal):
        """Execute a trading signal"""
        try:
            self.logger.info(f"Executing signal: {signal.action} {signal.quantity} {signal.contract_id} @ {signal.price}")
            
            # Notify signal handlers
            for handler in self.signal_handlers:
                try:
                    if asyncio.iscoroutinefunction(handler):
                        await handler(signal)
                    else:
                        handler(signal)
                except Exception as e:
                    self.logger.error(f"Error in signal handler: {e}")
            
            # Execute the order based on signal
            if signal.action in ["BUY", "SELL"]:
                await self._place_intraday_order(signal)
                
        except Exception as e:
            self.logger.error(f"Error executing signal: {e}")
    
    async def _place_intraday_order(self, signal: TradingSignal):
        """Place an order in the Intraday market"""
        try:
            order = IntradayOrder(
                portfolio_id=self.portfolio_id,
                contract_ids=[signal.contract_id],
                delivery_area_id=signal.area_id,
                side=signal.action,
                order_type=OrderType.LIMIT,
                unit_price=int(signal.price * 100),  # Convert to cents
                quantity=signal.quantity,
                time_in_force=TimeInForce.GFS,
                execution_restriction=ExecutionRestriction.NON,
                text=f"Auto-generated by {signal.strategy.value}"
            )
            
            request_id = await self.intraday_client.send_order(order)
            
            # Store order for tracking
            self.active_orders[order.client_order_id] = {
                "request_id": request_id,
                "order": order,
                "signal": signal,
                "timestamp": datetime.now()
            }
            
            self.logger.info(f"Placed intraday order {order.client_order_id}")
            
        except Exception as e:
            self.logger.error(f"Error placing intraday order: {e}")
    
    async def _manage_positions(self):
        """Manage existing positions and orders"""
        try:
            # Check for orders that need to be cancelled or modified
            current_time = datetime.now()
            
            for order_id, order_info in list(self.active_orders.items()):
                order_age = current_time - order_info["timestamp"]
                
                # Cancel orders older than 1 hour (example logic)
                if order_age > timedelta(hours=1):
                    await self._cancel_order(order_id)
            
        except Exception as e:
            self.logger.error(f"Error managing positions: {e}")
    
    async def _cancel_order(self, client_order_id: str):
        """Cancel an active order"""
        try:
            if client_order_id in self.active_orders:
                order_info = self.active_orders[client_order_id]
                
                # Find the actual order ID from execution reports
                # This is simplified - you'd need to track order IDs from execution reports
                await self.intraday_client.modify_order(
                    client_order_id,  # This should be the actual order ID
                    OrderModificationType.DELETE
                )
                
                self.logger.info(f"Cancelled order {client_order_id}")
                
        except Exception as e:
            self.logger.error(f"Error cancelling order {client_order_id}: {e}")
    
    # Event handlers for WebSocket messages
    
    async def _handle_configuration(self, data: Dict[str, Any]):
        """Handle configuration updates"""
        self.configuration = data
        self.logger.info("Configuration updated")
        
        # Log available portfolios and areas
        if "portfolios" in data:
            for portfolio in data["portfolios"]:
                self.logger.info(f"Portfolio: {portfolio.get('id')} - {portfolio.get('name')}")
    
    async def _handle_order_execution_report(self, data: Dict[str, Any]):
        """Handle order execution reports"""
        self.logger.info(f"Order execution report: {data}")
        
        # Update order status
        client_order_id = data.get("clientOrderId")
        if client_order_id in self.active_orders:
            self.active_orders[client_order_id]["execution_report"] = data
        
        # Notify order handlers
        for handler in self.order_handlers:
            try:
                if asyncio.iscoroutinefunction(handler):
                    await handler(data)
                else:
                    handler(data)
            except Exception as e:
                self.logger.error(f"Error in order handler: {e}")
    
    async def _handle_private_trade(self, data: Dict[str, Any]):
        """Handle private trade updates"""
        self.logger.info(f"Private trade: {data}")
        
        # Update positions based on trade
        await self._update_position_from_trade(data)
    
    async def _handle_local_view(self, data: Dict[str, Any]):
        """Handle local market view updates"""
        # Store market data for strategy use
        self.market_data["local_view"] = data
    
    async def _update_position_from_trade(self, trade_data: Dict[str, Any]):
        """Update position based on trade execution"""
        try:
            contract_id = trade_data.get("contractId")
            area_id = trade_data.get("areaId", 1)
            quantity = trade_data.get("quantity", 0)
            price = trade_data.get("price", 0)
            side = trade_data.get("side")
            
            if side == "SELL":
                quantity = -quantity
            
            position_key = f"{contract_id}_{area_id}"
            
            if position_key in self.positions:
                # Update existing position
                position = self.positions[position_key]
                total_quantity = position.quantity + quantity
                
                if total_quantity != 0:
                    # Calculate new average price
                    total_value = (position.quantity * position.average_price) + (quantity * price)
                    position.average_price = total_value / total_quantity
                    position.quantity = total_quantity
                    position.timestamp = datetime.now()
                else:
                    # Position closed
                    del self.positions[position_key]
            else:
                # Create new position
                self.positions[position_key] = TradingPosition(
                    contract_id=contract_id,
                    area_id=area_id,
                    quantity=quantity,
                    average_price=price,
                    timestamp=datetime.now(),
                    market="intraday"
                )
            
            # Notify position handlers
            if position_key in self.positions:
                for handler in self.position_handlers:
                    try:
                        if asyncio.iscoroutinefunction(handler):
                            await handler(self.positions[position_key])
                        else:
                            handler(self.positions[position_key])
                    except Exception as e:
                        self.logger.error(f"Error in position handler: {e}")
                        
        except Exception as e:
            self.logger.error(f"Error updating position from trade: {e}")
    
    # Public methods for manual trading
    
    async def place_day_ahead_block_order(
        self, 
        name: str, 
        price: float, 
        periods: List[Dict[str, Any]],
        minimum_acceptance_ratio: float = 1.0
    ) -> Dict[str, Any]:
        """Place a block order in the Day-Ahead market"""
        order = BlockOrderRequest(
            name=name,
            price=price,
            minimum_acceptance_ratio=minimum_acceptance_ratio,
            linked_to=None,
            exclusive_group=None,
            periods=periods
        )
        
        return await self.day_ahead_client.submit_block_order(order)
    
    async def place_intraday_limit_order(
        self,
        contract_id: str,
        side: str,
        quantity: int,
        price: float,
        area_id: int = 1
    ) -> str:
        """Place a limit order in the Intraday market"""
        order = IntradayOrder(
            portfolio_id=self.portfolio_id,
            contract_ids=[contract_id],
            delivery_area_id=area_id,
            side=side,
            order_type=OrderType.LIMIT,
            unit_price=int(price * 100),  # Convert to cents
            quantity=quantity,
            time_in_force=TimeInForce.GFS,
            execution_restriction=ExecutionRestriction.NON,
            text="Manual order"
        )
        
        request_id = await self.intraday_client.send_order(order)
        
        # Store order for tracking
        self.active_orders[order.client_order_id] = {
            "request_id": request_id,
            "order": order,
            "timestamp": datetime.now()
        }
        
        return order.client_order_id
    
    def enable_auto_trading(self):
        """Enable automatic trading based on strategy"""
        self.auto_trading_enabled = True
        self.logger.info("Auto trading enabled")
    
    def disable_auto_trading(self):
        """Disable automatic trading"""
        self.auto_trading_enabled = False
        self.logger.info("Auto trading disabled")
    
    def add_signal_handler(self, handler: Callable[[TradingSignal], None]):
        """Add a handler for trading signals"""
        self.signal_handlers.append(handler)
    
    def add_position_handler(self, handler: Callable[[TradingPosition], None]):
        """Add a handler for position updates"""
        self.position_handlers.append(handler)
    
    def add_order_handler(self, handler: Callable[[Dict[str, Any]], None]):
        """Add a handler for order updates"""
        self.order_handlers.append(handler)
    
    def get_positions(self) -> Dict[str, TradingPosition]:
        """Get current positions"""
        return self.positions.copy()
    
    def get_active_orders(self) -> Dict[str, Dict[str, Any]]:
        """Get active orders"""
        return self.active_orders.copy()
    
    def get_market_data(self) -> Dict[str, Any]:
        """Get current market data"""
        return self.market_data.copy()
